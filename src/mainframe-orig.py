#!/usr/bin/env python
# -*- coding: latin-1; py-indent-offset:4 -*-
################################################################################
# 
#   Copyright (C) 2013 Daniel Rodriguez
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################
"""Subclass of MainFrame, which is generated by wxFormBuilder."""

from collections import OrderedDict
import datetime
import itertools

import openpyxl
import xlrd
import wx

import maingui

import config
from mvcbase import ViewRole, PubSend, PubSubscribe
import rpcsupport

# Implementing MainFrame

@ViewRole
class MainFrame(maingui.MainFrame):
    baseurl = config.ConfigString(name='baseurl', defvalue='')
    username = config.ConfigString(name='username', defvalue='')
    password = config.ConfigString(name='password', defvalue='')
    excelfile = config.ConfigString(name='excelfile', defvalue='')
    catalogname = config.ConfigString(name='catalogname', defvalue='')
    sheetname = config.ConfigString(name='sheetname', defvalue='')

    def __init__(self, parent):
        maingui.MainFrame.__init__(self, parent)

        self.m_filePickerExcel.SetPath(self.excelfile)
        self.m_textCtrlUrl.SetValue(self.baseurl)
        self.m_textCtrlUsername.SetValue(self.username)
        self.m_textCtrlPassword.SetValue(self.password)
        self.m_textCtrlCatalogName.SetValue(self.catalogname)
        self.m_textCtrlSheetName.SetValue(self.sheetname)


    def OnButtonClickDeleteCatalog(self, event):
        event.Skip()
        item = self.m_choiceCatalogs.GetSelection()
        if item == wx.NOT_FOUND:
            return

        itemtxt = self.m_choiceCatalogs.GetString(item)

        catalog = self.m_choiceCatalogs.GetClientData(item)
        catid = catalog[0]
        rpcinterface = rpcsupport.RpcInterface(self.baseurl, self.username, self.password)
        retcode, retval = rpcinterface.deleteTestCatalog(catid)
        if not retcode:
            self.LogAppend(retval)
            wx.MessageBox('See log for details', 'Error loading catalogs')
            return

        self.LogAppend('Deleted catalog %s with catalog id %s' % (itemtxt, catid))

        self.m_choiceCatalogs.Delete(item)
        if self.m_choiceCatalogs.GetCount():
            newitem = item -1 if item > 0 else 0
            self.m_choiceCatalogs.SetSelection(newitem)


    def LogAppend(self, txt):
        dt = datetime.datetime.now().isoformat()
        self.m_textCtrlLog.AppendText('%s: %s\n' % (dt, txt))

    def OnButtonClearLog(self, event):
        event.Skip()
        self.m_textCtrlLog.Clear()

    def OnButtonClickExit(self, event):
        event.Skip()
        self.Destroy()
        
    def OnButtonClickClearRegistry(self, event):
        event.Skip()
        wx.Config.Get().DeleteAll()

    def ReloadSheets(self):
        self.m_choiceSheets.Clear()
        workbook = xlrd.open_workbook(self.excelfile)
        self.m_choiceSheets.AppendItems(workbook.sheet_names())
        if self.m_choiceSheets.GetCount():
            self.m_choiceSheets.SetSelection(0)

    def OnFileChangedExcel(self, event):
        event.Skip()
        self.excelfile = self.m_filePickerExcel.GetPath()
        self.ReloadSheets()

    def OnButtonClickReloadSheets(self, event):
        event.Skip()
        self.ReloadSheets()

    def OnKillFocusUrl(self, event):
        event.Skip()
        self.baseurl = self.m_textCtrlUrl.GetValue()

    def OnKillFocusUsername(self, event):
        event.Skip()
        self.username = self.m_textCtrlUsername.GetValue()

    def OnKillFocusPassword(self, event):
        event.Skip()
        self.password = self.m_textCtrlPassword.GetValue()

    def OnKillFocusCatalogName(self, event):
        event.Skip()
        self.catalogname = self.m_textCtrlCatalogName.GetValue()

    def OnKillFocusSheetName(self, event):
        event.Skip()
        self.sheetname = self.m_textCtrlSheetName.GetValue()

    def OnButtonClickReloadCatalogs(self, event):
        event.Skip()
        rpcinterface = rpcsupport.RpcInterface(self.baseurl, self.username, self.password)

        retcode, catalogs = rpcinterface.listRootCatalogs()
        if not retcode:
            self.LogAppend(catalogs)
            wx.MessageBox('See log for details', 'Error loading catalogs')
            return

        self.LogAppend('Retrieved %d catalogs' % len(catalogs))

        self.m_choiceCatalogs.Clear()
        for catalog in catalogs:
            self.m_choiceCatalogs.Append(catalog[2], catalog)
        
        if self.m_choiceCatalogs.GetCount():
            self.m_choiceCatalogs.SetSelection(0)
        
    def OnButtonClickExcel2Server(self, event):
        event.Skip()

        item = self.m_choiceSheets.GetSelection()
        if item == wx.NOT_FOUND:
            self.LogAppend('No Excel Sheet selected/available. Cannot send info to server')
            return

        self.LogAppend('Using Excel file %s' % self.excelfile)
        # Open Workbook and sheet
        self.LogAppend('Opening excel file %s' % self.excelfile)
        workbook = xlrd.open_workbook(self.excelfile)
        chosensheet = self.m_choiceSheets.GetStringSelection()
        self.LogAppend('Choosing sheet %s' % chosensheet)
        wksheet = workbook.sheet_by_name(chosensheet)

        self.LogAppend('Parsing TestCases Categories, to create subcatalogs')
        headerfields = dict()
        catcols = 0
        tcdescription = 'Test Case Fields'
        row = 0
        while True:
            cellvalue = wksheet.cell_value(row, catcols)
            if not cellvalue:
                break
            headerfields[catcols] = cellvalue
            tcdescription += ':%s' % cellvalue
            catcols += 1

        self.LogAppend('Excel header has %d columns' % catcols)
        self.LogAppend('Header names %s' % str(headerfields).strip('[]'))

        self.LogAppend('Creating Catalog %s' % self.catalogname)
        rpcinterface = rpcsupport.RpcInterface(self.baseurl, self.username, self.password)
        retcode, rootid = rpcinterface.createTestCatalog('', self.catalogname, tcdescription)

        if not retcode:
            self.LogAppend(rootid)
            wx.MessageBox('See log for details', 'Error Creating Catalog')
            return
        self.LogAppend('Created Catalog with id %s' % rootid)

        # Parse the Category and subcategory columns
        categories = dict()
        while True:
            colidx = itertools.count()
            row += 1
            try:
                maincat = wksheet.cell_value(row, colidx.next())
            except IndexError:
                maincat = None

            if not maincat: # if row >= wksheet.nrows
                self.LogAppend('End of TestCases')
                break # end of testcases

            # Get the main category (create if needed as child of root)
            if maincat not in categories:
                self.LogAppend('Creating SubCatalog %s' % maincat)
                retcode, catid = rpcinterface.createTestCatalog(rootid, maincat, '')
                if not retcode:
                    self.LogAppend(catid)
                    wx.MessageBox('See log for details', 'Error Creating Sub-Catalog')
                    return

                categories[maincat] = catid
                self.LogAppend('Created SubCatalog %s with id %s' % (maincat, catid))
            else:
                self.LogAppend('Next Testcase - Category %s' % maincat)
                catid = categories[maincat]

            # Get the sub category (create if needed as child of main category)
            subcat = wksheet.cell_value(row, colidx.next())
            if subcat:
                subcatkey = '%s::%s' % (maincat, subcat)
                if subcatkey not in categories:
                    self.LogAppend('Creating SubSubCatalog %s' % subcat)
                    retcode, catid = rpcinterface.createTestCatalog(catid, subcat, '')
                    if not retcode:
                        self.LogAppend(catid)
                        wx.MessageBox('See log for details', 'Error Creating Sub-Sub-Catalog')
                        return

                    categories[subcatkey] = catid
                    self.LogAppend('Created SubSubCatalog %s with id %s' % (subcat, catid))
                else:
                    self.LogAppend('Next Testcase - Category %s' % subcatkey)
                    catid = categories[subcatkey]

            # Get the title
            tctitle = wksheet.cell_value(row, colidx.next())

            # Get Description and complete
            tcdesc = wksheet.cell_value(row, colidx.next())
            for col in xrange(colidx.next(), catcols):
                tcdesc += '\n\n'
                tcdesc += '== %s ==\n' % headerfields[col]
                cellvalue = wksheet.cell_value(row, col)
                celltype = wksheet.cell_type(row, col)
                if celltype != xlrd.XL_CELL_TEXT:
                    cellvalue = str(cellvalue)
                tcdesc += cellvalue
                tcdesc += '\n\n'

            # Testcase is complete and we have a cat id
            self.LogAppend('Creating testcase %d with title %s' % (row, tctitle))
            retcode, tcid = rpcinterface.createTestCase(catid, tctitle, tcdesc)
            if not retcode:
                self.LogAppend(tcid)
                wx.MessageBox('See log for details', 'Error Creating TestCase')
                return

            self.LogAppend('%d TestCase create (id %s/catalog id %s)' % (row, tcid, catid))

    def OnButtonClickServer2Excel(self, event):
        event.Skip()

        catitem = self.m_choiceCatalogs.GetSelection()
        if catitem == wx.NOT_FOUND:
            self.LogAppend('No Catalog Selected/Available. Cannot fecth info from server')
            return
        
        rootcat = self.m_choiceCatalogs.GetClientData(catitem)
        rootid = rootcat[0]

        # Prepare for Excel
        sheetname = self.sheetname
        if not sheetname:
            self.LogAppend('No sheetname given. Cannot fecth info from server')
            return

        # Open Excel
        workbook = openpyxl.reader.excel.load_workbook(self.excelfile)
        sheetnames = workbook.get_sheet_names()
        if sheetname in sheetnames:
            self.LogAppend('Sheetname already exists. No overwrite yet')
            return

        wksheet = workbook.create_sheet(title=sheetname)

        # Connect to Server
        rpcinterface = rpcsupport.RpcInterface(self.baseurl, self.username, self.password)
        
        retcode, rootcat = rpcinterface.getTestCatalog(rootid)
        rootcat.insert(0, rootid)
        catalogs = [rootcat]
        catdesc = rootcat[3]
        headers = catdesc.split(':')[1:]

        row = 0
        for col, header in enumerate(headers):
            wksheet.cell(row=row, column=col).value = header

        tt2category = dict()
        # Go for it
        while catalogs:

            nextcatalogs = list()
            for catalog in catalogs:
                tt2category[catalog[0]] = catalog[2] # map id to category (catalog name)

                retcode, subcatalogs = rpcinterface.listSubCatalogs(catalog[0])
                nextcatalogs.extend(subcatalogs)

                retcode, testcases = rpcinterface.listTestCases(catalog[0])
                for tc in testcases:
                    row += 1
                    colidx = itertools.count()
                    tctitle = tc[2]
                    tcdesc = tc[3]
                    # TC_TT0_TT1_TC32
                    # TC_TT0_TT1_TT2_TC33
                    tcname = tc[1]
                    txt = tcname[2:]
                    txt = txt.split('_TC')[0]
                    ttparts = txt.split('_TT')[1:]
                    category = ''
                    subcategory = ''

                    if len(ttparts) > 1:
                        category = tt2category[ttparts[1]]
                    if len(ttparts) > 2:
                        subcategory = tt2category[ttparts[2]]

                    wksheet.cell(row=row, column=colidx.next()).value = category
                    wksheet.cell(row=row, column=colidx.next()).value = subcategory
                    wksheet.cell(row=row, column=colidx.next()).value = tctitle

                    tcdescparts = self.ParseDesc(tcdesc, headers)
                    for desckey, descfield in tcdescparts.iteritems():
                        col = colidx.next()
                        wksheet.cell(row=row, column=col).set_value_explicit(descfield)
                        wksheet.cell(row=row, column=col).style.alignment.wrap_text = True

            catalogs = nextcatalogs
        workbook.save(self.excelfile)


    def ParseDesc(self, desc, headers, startcol=3):
        curheader = headers[startcol]
        parsed = OrderedDict([(curheader, '')])

        lines = desc.split('\n')
        for line in lines:
            if line.startswith('=='):
                # curheader = line.strip('\n= ')
                startcol += 1
                curheader = headers[startcol]
                parsed[curheader] = ''
            elif not line:
                continue
            else:
                parsed[curheader] += line + '\n'

        return parsed
